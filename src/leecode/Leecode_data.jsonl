{"date": "2024-01-11-12-01", "error": false, "url": "https://leetcode.com/problems/count-number-of-possible-root-nodes", "text_blocks": "Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\n\nAlice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\n\nChooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\nHe tells Alice that u is the parent of v in the tree.\n\nBob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\n\nAlice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\n\nGiven the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.\n\n \n\nExample 1:\n\nInput: edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\nOutput: 3\nExplanation: \nRoot = 0, correct guesses = [1,3], [0,1], [2,4]\nRoot = 1, correct guesses = [1,3], [1,0], [2,4]\nRoot = 2, correct guesses = [1,3], [1,0], [2,4]\nRoot = 3, correct guesses = [1,0], [2,4]\nRoot = 4, correct guesses = [1,3], [1,0]\nConsidering 0, 1, or 2 as root node leads to 3 correct guesses.\n\n\n\nExample 2:\n\nInput: edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\nOutput: 5\nExplanation: \nRoot = 0, correct guesses = [3,4]\nRoot = 1, correct guesses = [1,0], [3,4]\nRoot = 2, correct guesses = [1,0], [2,1], [3,4]\nRoot = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]\nRoot = 4, correct guesses = [1,0], [2,1], [3,2]\nConsidering any node as root will give at least 1 correct guess. \n\n\n\n \n\nConstraints:\n\nedges.length == n - 1\n2 <= n <= 105\n1 <= guesses.length <= 105\n0 <= ai, bi, uj, vj <= n - 1\nai != bi\nuj != vj\nedges represents a valid tree.\nguesses[j] is an edge of the tree.\nguesses is unique.\n0 <= k <= guesses.length"}
{"date": "2024-01-11-12-01", "error": false, "url": "https://leetcode.com/problems/split-the-array-to-make-coprime-products", "text_blocks": "You are given a 0-indexed integer array nums of length n.\n\nA split at an index i where 0 <= i <= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime.\n\nFor example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime. A split at the index i = 2 is not valid because i == n - 1.\n\nReturn the smallest index i at which the array can be split validly or -1 if there is no such split.\n\nTwo values val1 and val2 are coprime if gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor of val1 and val2.\n\n \n\nExample 1:\n\nInput: nums = [4,7,8,15,3,5]\nOutput: 2\nExplanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThe only valid split is at index 2.\n\n\nExample 2:\n\nInput: nums = [4,7,15,8,3,5]\nOutput: -1\nExplanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThere is no valid split.\n\n\n \n\nConstraints:\n\nn == nums.length\n1 <= n <= 104\n1 <= nums[i] <= 106"}
{"date": "2024-01-11-12-01", "error": false, "url": "https://leetcode.com/problems/number-of-ways-to-earn-points", "text_blocks": "There is a test that has n types of questions. You are given an integer target and a 0-indexed 2D integer array types where types[i] = [counti, marksi] indicates that there are counti questions of the ith type, and each one of them is worth marksi points.\n\nReturn the number of ways you can earn exactly target points in the exam. Since the answer may be too large, return it modulo 109 + 7.\n\nNote that questions of the same type are indistinguishable.\n\nFor example, if there are 3 questions of the same type, then solving the 1st and 2nd questions is the same as solving the 1st and 3rd questions, or the 2nd and 3rd questions.\n\n \n\nExample 1:\n\nInput: target = 6, types = [[6,1],[3,2],[2,3]]\nOutput: 7\nExplanation: You can earn 6 points in one of the seven ways:\n- Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6\n- Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6\n- Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6\n- Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6\n- Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6\n- Solve 3 questions of the 1st type: 2 + 2 + 2 = 6\n- Solve 2 questions of the 2nd type: 3 + 3 = 6\n\n\nExample 2:\n\nInput: target = 5, types = [[50,1],[50,2],[50,5]]\nOutput: 4\nExplanation: You can earn 5 points in one of the four ways:\n- Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5\n- Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5\n- Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5\n- Solve 1 question of the 2nd type: 5\n\n\nExample 3:\n\nInput: target = 18, types = [[6,1],[3,2],[2,3]]\nOutput: 1\nExplanation: You can only earn 18 points by answering all questions.\n\n\n \n\nConstraints:\n\n1 <= target <= 1000\nn == types.length\n1 <= n <= 50\ntypes[i].length == 2\n1 <= counti, marksi <= 50"}
{"date": "2024-01-11-12-01", "error": false, "url": "https://leetcode.com/problems/minimum-time-to-complete-all-tasks", "text_blocks": "There is a computer that can run an unlimited number of tasks at the same time. You are given a 2D integer array tasks where tasks[i] = [starti, endi, durationi] indicates that the ith task should run for a total of durationi seconds (not necessarily continuous) within the inclusive time range [starti, endi].\n\nYou may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.\n\nReturn the minimum time during which the computer should be turned on to complete all tasks.\n\n \n\nExample 1:\n\nInput: tasks = [[2,3,1],[4,5,1],[1,5,2]]\nOutput: 2\nExplanation: \n- The first task can be run in the inclusive time range [2, 2].\n- The second task can be run in the inclusive time range [5, 5].\n- The third task can be run in the two inclusive time ranges [2, 2] and [5, 5].\nThe computer will be on for a total of 2 seconds.\n\n\nExample 2:\n\nInput: tasks = [[1,3,2],[2,5,3],[5,6,2]]\nOutput: 4\nExplanation: \n- The first task can be run in the inclusive time range [2, 3].\n- The second task can be run in the inclusive time ranges [2, 3] and [5, 5].\n- The third task can be run in the two inclusive time range [5, 6].\nThe computer will be on for a total of 4 seconds.\n\n\n \n\nConstraints:\n\n1 <= tasks.length <= 2000\ntasks[i].length == 3\n1 <= starti, endi <= 2000\n1 <= durationi <= endi - starti + 1 "}
{"date": "2024-01-11-12-02", "error": false, "url": "https://leetcode.com/problems/collect-coins-in-a-tree", "text_blocks": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given an integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an array coins of size n where coins[i] can be either 0 or 1, where 1 indicates the presence of a coin in the vertex i.\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times: \n\nCollect all the coins that are at a distance of at most 2 from the current vertex, or\nMove to any adjacent vertex in the tree.\n\nFind the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex.\n\nNote that if you pass an edge several times, you need to count it into the answer several times.\n\n \n\nExample 1:\n\nInput: coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\nOutput: 2\nExplanation: Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n\nExample 2:\n\nInput: coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]\nOutput: 2\nExplanation: Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n\n \n\nConstraints:\n\nn == coins.length\n1 <= n <= 3 * 104\n0 <= coins[i] <= 1\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi < n\nai != bi\nedges represents a valid tree."}
{"date": "2024-01-11-12-02", "error": false, "url": "https://leetcode.com/problems/shortest-cycle-in-a-graph", "text_blocks": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1. The edges in the graph are represented by a given 2D integer array edges, where edges[i] = [ui, vi] denotes an edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\n\nReturn the length of the shortest cycle in the graph. If no cycle exists, return -1.\n\nA cycle is a path that starts and ends at the same node, and each edge in the path is used only once.\n\n \n\nExample 1:\n\nInput: n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\nOutput: 3\nExplanation: The cycle with the smallest length is : 0 -> 1 -> 2 -> 0 \n\n\nExample 2:\n\nInput: n = 4, edges = [[0,1],[0,2]]\nOutput: -1\nExplanation: There are no cycles in this graph.\n\n\n \n\nConstraints:\n\n2 <= n <= 1000\n1 <= edges.length <= 1000\nedges[i].length == 2\n0 <= ui, vi < n\nui != vi\nThere are no repeated edges."}
{"date": "2024-01-11-12-02", "error": false, "url": "https://leetcode.com/problems/minimum-reverse-operations", "text_blocks": "You are given an integer n and an integer p in the range [0, n - 1]. Representing a 0-indexed array arr of length n where all positions are set to 0's, except position p which is set to 1.\n\nYou are also given an integer array banned containing some positions from the array. For the ith position in banned, arr[banned[i]] = 0, and banned[i] != p.\n\nYou can perform multiple operations on arr. In an operation, you can choose a subarray with size k and reverse the subarray. However, the 1 in arr should never go to any of the positions in banned. In other words, after each operation arr[banned[i]] remains 0.\n\nReturn an array ans where for each i from [0, n - 1], ans[i] is the minimum number of reverse operations needed to bring the 1 to position i in arr, or -1 if it is impossible.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe values of ans[i] are independent for all i's.\nThe reverse of an array is an array containing the values in reverse order.\n\n \n\nExample 1:\n\nInput: n = 4, p = 0, banned = [1,2], k = 4\nOutput: [0,-1,-1,1]\nExplanation: In this case k = 4 so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1 is placed at position 0 so the amount of operations we need for position 0 is 0. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is -1. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is 1. \n\n\nExample 2:\n\nInput: n = 5, p = 0, banned = [2,4], k = 3\nOutput: [0,-1,-1,-1,-1]\nExplanation: In this case the 1 is initially at position 0, so the answer for that position is 0. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray [0, 2] for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn't happen. So, we can't move the 1 from position 0, making the result for all the other positions -1. \n\n\nExample 3:\n\nInput: n = 4, p = 2, banned = [0,1,3], k = 1\nOutput: [-1,-1,0,-1]\nExplanation: In this case we can only perform reverse operations of size 1. So the 1 never changes its position.\n\n\n \n\nConstraints:\n\n1 <= n <= 105\n0 <= p <= n - 1\n0 <= banned.length <= n - 1\n0 <= banned[i] <= n - 1\n1 <= k <= n \nbanned[i] != p\nall values in banned are unique "}
