{"date": "2023-12-20-16-28", "error": false, "url": "https://leetcode.com/problems/maximum-sum-queries", "text_blocks": "给你两个长度为 n 、下标从 0 开始的整数数组 nums1 和 nums2 ，另给你一个下标从 1 开始的二维数组 queries ，其中 queries[i] = [xi, yi] 。\n\n对于第 i 个查询，在所有满足 nums1[j] >= xi 且 nums2[j] >= yi 的下标 j (0 <= j < n) 中，找出 nums1[j] + nums2[j] 的 最大值 ，如果不存在满足条件的 j 则返回 -1 。\n\n返回数组 answer ，其中 answer[i] 是第 i 个查询的答案。\n\n \n\n示例 1：\n\n输入：nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]\n输出：[6,10,7]\n解释：\n对于第 1 个查询：xi = 4 且 yi = 1 ，可以选择下标 j = 0 ，此时 nums1[j] >= 4 且 nums2[j] >= 1 。nums1[j] + nums2[j] 等于 6 ，可以证明 6 是可以获得的最大值。\n对于第 2 个查询：xi = 1 且 yi = 3 ，可以选择下标 j = 2 ，此时 nums1[j] >= 1 且 nums2[j] >= 3 。nums1[j] + nums2[j] 等于 10 ，可以证明 10 是可以获得的最大值。\n对于第 3 个查询：xi = 2 且 yi = 5 ，可以选择下标 j = 3 ，此时 nums1[j] >= 2 且 nums2[j] >= 5 。nums1[j] + nums2[j] 等于 7 ，可以证明 7 是可以获得的最大值。\n因此，我们返回 [6,10,7] 。\n\n\n示例 2：\n\n输入：nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]\n输出：[9,9,9]\n解释：对于这个示例，我们可以选择下标 j = 2 ，该下标可以满足每个查询的限制。\n\n\n示例 3：\n\n输入：nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]\n输出：[-1]\n解释：示例中的查询 xi = 3 且 yi = 3 。对于每个下标 j ，都只满足 nums1[j] < xi 或者 nums2[j] < yi 。因此，不存在答案。 \n\n\n \n\n提示：\n\nnums1.length == nums2.length \nn == nums1.length \n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= 109 \n1 <= queries.length <= 105\nqueries[i].length == 2\nxi == queries[i][1]\nyi == queries[i][2]\n1 <= xi, yi <= 109"}
{"date": "2023-12-20-16-28", "error": false, "url": "https://leetcode.com/problems/painting-the-walls", "text_blocks": "给你两个长度为 n 下标从 0 开始的整数数组 cost 和 time ，分别表示给 n 堵不同的墙刷油漆需要的开销和时间。你有两名油漆匠：\n\n一位需要 付费 的油漆匠，刷第 i 堵墙需要花费 time[i] 单位的时间，开销为 cost[i] 单位的钱。\n一位 免费 的油漆匠，刷 任意 一堵墙的时间为 1 单位，开销为 0 。但是必须在付费油漆匠 工作 时，免费油漆匠才会工作。\n\n请你返回刷完 n 堵墙最少开销为多少。\n\n \n\n示例 1：\n\n输入：cost = [1,2,3,2], time = [1,2,3,2]\n输出：3\n解释：下标为 0 和 1 的墙由付费油漆匠来刷，需要 3 单位时间。同时，免费油漆匠刷下标为 2 和 3 的墙，需要 2 单位时间，开销为 0 。总开销为 1 + 2 = 3 。\n\n\n示例 2：\n\n输入：cost = [2,3,4,2], time = [1,1,1,1]\n输出：4\n解释：下标为 0 和 3 的墙由付费油漆匠来刷，需要 2 单位时间。同时，免费油漆匠刷下标为 1 和 2 的墙，需要 2 单位时间，开销为 0 。总开销为 2 + 2 = 4 。\n\n\n \n\n提示：\n\n1 <= cost.length <= 500\ncost.length == time.length\n1 <= cost[i] <= 106\n1 <= time[i] <= 500"}
{"date": "2023-12-20-16-28", "error": false, "url": "https://leetcode.com/problems/robot-collisions", "text_blocks": "现有 n 个机器人，编号从 1 开始，每个机器人包含在路线上的位置、健康度和移动方向。\n\n给你下标从 0 开始的两个整数数组 positions、healths 和一个字符串 directions（directions[i] 为 'L' 表示 向左 或 'R' 表示 向右）。 positions 中的所有整数 互不相同 。\n\n所有机器人以 相同速度 同时 沿给定方向在路线上移动。如果两个机器人移动到相同位置，则会发生 碰撞 。\n\n如果两个机器人发生碰撞，则将 健康度较低 的机器人从路线中 移除 ，并且另一个机器人的健康度 减少 1 。幸存下来的机器人将会继续沿着与之前 相同 的方向前进。如果两个机器人的健康度相同，则将二者都从路线中移除。\n\n请你确定全部碰撞后幸存下的所有机器人的 健康度 ，并按照原来机器人编号的顺序排列。即机器人 1 （如果幸存）的最终健康度，机器人 2 （如果幸存）的最终健康度等。 如果不存在幸存的机器人，则返回空数组。\n\n在不再发生任何碰撞后，请你以数组形式，返回所有剩余机器人的健康度（按机器人输入中的编号顺序）。\n\n注意：位置  positions 可能是乱序的。\n\n \n\n示例 1：\n\n输入：positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = \"RRRRR\"\n输出：[2,17,9,15,10]\n解释：在本例中不存在碰撞，因为所有机器人向同一方向移动。所以，从第一个机器人开始依序返回健康度，[2, 17, 9, 15, 10] 。\n\n\n示例 2：\n\n输入：positions = [3,5,2,6], healths = [10,10,15,12], directions = \"RLRL\"\n输出：[14]\n解释：本例中发生 2 次碰撞。首先，机器人 1 和机器人 2 将会碰撞，因为二者健康度相同，二者都将被从路线中移除。接下来，机器人 3 和机器人 4 将会发生碰撞，由于机器人 4 的健康度更小，则它会被移除，而机器人 3 的健康度变为 15 - 1 = 14 。仅剩机器人 3 ，所以返回 [14] 。\n\n\n示例 3：\n\n输入：positions = [1,2,5,6], healths = [10,10,11,11], directions = \"RLRL\"\n输出：[]\n解释：机器人 1 和机器人 2 将会碰撞，因为二者健康度相同，二者都将被从路线中移除。机器人 3 和机器人 4 将会碰撞，因为二者健康度相同，二者都将被从路线中移除。所以返回空数组 [] 。\n\n \n\n提示：\n\n1 <= positions.length == healths.length == directions.length == n <= 105\n1 <= positions[i], healths[i] <= 109\ndirections[i] == 'L' 或 directions[i] == 'R'\npositions 中的所有值互不相同"}
{"date": "2023-12-20-16-28", "error": false, "url": "https://leetcode.com/problems/sum-of-imbalance-numbers-of-all-subarrays", "text_blocks": "一个长度为 n 下标从 0 开始的整数数组 arr 的 不平衡数字 定义为，在 sarr = sorted(arr) 数组中，满足以下条件的下标数目：\n\n0 <= i < n - 1 ，和\nsarr[i+1] - sarr[i] > 1\n\n这里，sorted(arr) 表示将数组 arr 排序后得到的数组。\n\n给你一个下标从 0 开始的整数数组 nums ，请你返回它所有 子数组 的 不平衡数字 之和。\n\n子数组指的是一个数组中连续一段 非空 的元素序列。\n\n \n\n示例 1：\n\n输入：nums = [2,3,1,4]\n输出：3\n解释：总共有 3 个子数组有非 0 不平衡数字：\n- 子数组 [3, 1] ，不平衡数字为 1 。\n- 子数组 [3, 1, 4] ，不平衡数字为 1 。\n- 子数组 [1, 4] ，不平衡数字为 1 。\n其他所有子数组的不平衡数字都是 0 ，所以所有子数组的不平衡数字之和为 3 。\n\n\n示例 2：\n\n输入：nums = [1,3,3,3,5]\n输出：8\n解释：总共有 7 个子数组有非 0 不平衡数字：\n- 子数组 [1, 3] ，不平衡数字为 1 。\n- 子数组 [1, 3, 3] ，不平衡数字为 1 。\n- 子数组 [1, 3, 3, 3] ，不平衡数字为 1 。\n- 子数组 [1, 3, 3, 3, 5] ，不平衡数字为 2 。\n- 子数组 [3, 3, 3, 5] ，不平衡数字为 1 。\n- 子数组 [3, 3, 5] ，不平衡数字为 1 。\n- 子数组 [3, 5] ，不平衡数字为 1 。\n其他所有子数组的不平衡数字都是 0 ，所以所有子数组的不平衡数字之和为 8 。\n\n \n\n提示：\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= nums.length"}
{"date": "2023-12-20-16-28", "error": false, "url": "https://leetcode.com/problems/length-of-the-longest-valid-substring", "text_blocks": "给你一个字符串 word 和一个字符串数组 forbidden 。\n\n如果一个字符串不包含 forbidden 中的任何字符串，我们称这个字符串是 合法 的。\n\n请你返回字符串 word 的一个 最长合法子字符串 的长度。\n\n子字符串 指的是一个字符串中一段连续的字符，它可以为空。\n\n \n\n示例 1：\n\n输入：word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\n输出：4\n解释：总共有 11 个合法子字符串：\"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\" 和 \"aabc\"。最长合法子字符串的长度为 4 。\n其他子字符串都要么包含 \"aaa\" ，要么包含 \"cb\" 。\n\n示例 2：\n\n输入：word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\n输出：4\n解释：总共有 11 个合法子字符串：\"l\" ，\"t\" ，\"c\" ，\"o\" ，\"d\" ，\"tc\" ，\"co\" ，\"od\" ，\"tco\" ，\"cod\" 和 \"tcod\" 。最长合法子字符串的长度为 4 。\n所有其他子字符串都至少包含 \"de\" ，\"le\" 和 \"e\" 之一。\n\n\n \n\n提示：\n\n1 <= word.length <= 105\nword 只包含小写英文字母。\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] 只包含小写英文字母。"}
{"date": "2023-12-20-16-28", "error": false, "url": "https://leetcode.com/problems/maximum-number-of-groups-with-increasing-length", "text_blocks": "给你一个下标从 0 开始、长度为 n 的数组 usageLimits 。\n\n你的任务是使用从 0 到 n - 1 的数字创建若干组，并确保每个数字 i 在 所有组 中使用的次数总共不超过 usageLimits[i] 次。此外，还必须满足以下条件：\n\n每个组必须由 不同 的数字组成，也就是说，单个组内不能存在重复的数字。\n每个组（除了第一个）的长度必须 严格大于 前一个组。\n\n在满足所有条件的情况下，以整数形式返回可以创建的最大组数。\n\n \n\n示例 1：\n\n输入：usageLimits = [1,2,5]\n输出：3\n解释：在这个示例中，我们可以使用 0 至多一次，使用 1 至多 2 次，使用 2 至多 5 次。\n一种既能满足所有条件，又能创建最多组的方式是： \n组 1 包含数字 [2] 。\n组 2 包含数字 [1,2] 。\n组 3 包含数字 [0,1,2] 。 \n可以证明能够创建的最大组数是 3 。 \n所以，输出是 3 。 \n\n示例 2：\n\n输入：usageLimits = [2,1,2]\n输出：2\n解释：在这个示例中，我们可以使用 0 至多 2 次，使用 1 至多 1 次，使用 2 至多 2 次。\n一种既能满足所有条件，又能创建最多组的方式是： \n组 1 包含数字 [0] 。 \n组 2 包含数字 [1,2] 。\n可以证明能够创建的最大组数是 2 。 \n所以，输出是 2 。 \n\n\n示例 3：\n\n输入：usageLimits = [1,1]\n输出：1\n解释：在这个示例中，我们可以使用 0 和 1 至多 1 次。 \n一种既能满足所有条件，又能创建最多组的方式是：\n组 1 包含数字 [0] 。\n可以证明能够创建的最大组数是 1 。 \n所以，输出是 1 。 \n\n\n \n\n提示：\n\n1 <= usageLimits.length <= 105\n1 <= usageLimits[i] <= 109"}
{"date": "2023-12-20-16-28", "error": false, "url": "https://leetcode.com/problems/count-paths-that-can-form-a-palindrome-in-a-tree", "text_blocks": "给你一棵 树（即，一个连通、无向且无环的图），根 节点为 0 ，由编号从 0 到 n - 1 的 n 个节点组成。这棵树用一个长度为 n 、下标从 0 开始的数组 parent 表示，其中 parent[i] 为节点 i 的父节点，由于节点 0 为根节点，所以 parent[0] == -1 。\n\n另给你一个长度为 n 的字符串 s ，其中 s[i] 是分配给 i 和 parent[i] 之间的边的字符。s[0] 可以忽略。\n\n找出满足 u < v ，且从 u 到 v 的路径上分配的字符可以 重新排列 形成 回文 的所有节点对 (u, v) ，并返回节点对的数目。\n\n如果一个字符串正着读和反着读都相同，那么这个字符串就是一个 回文 。\n\n \n\n示例 1：\n\n输入：parent = [-1,0,0,1,1,2], s = \"acaabc\"\n输出：8\n解释：符合题目要求的节点对分别是：\n- (0,1)、(0,2)、(1,3)、(1,4) 和 (2,5) ，路径上只有一个字符，满足回文定义。\n- (2,3)，路径上字符形成的字符串是 \"aca\" ，满足回文定义。\n- (1,5)，路径上字符形成的字符串是 \"cac\" ，满足回文定义。\n- (3,5)，路径上字符形成的字符串是 \"acac\" ，可以重排形成回文 \"acca\" 。\n\n\n示例 2：\n\n输入：parent = [-1,0,0,0,0], s = \"aaaaa\"\n输出：10\n解释：任何满足 u < v 的节点对 (u,v) 都符合题目要求。\n\n\n \n\n提示：\n\nn == parent.length == s.length\n1 <= n <= 105\n对于所有 i >= 1 ，0 <= parent[i] <= n - 1 均成立\nparent[0] == -1\nparent 表示一棵有效的树\ns 仅由小写英文字母组成"}
{"date": "2023-12-20-16-29", "error": false, "url": "https://leetcode.com/problems/count-stepping-numbers-in-range", "text_blocks": "给你两个正整数 low 和 high ，都用字符串表示，请你统计闭区间 [low, high] 内的 步进数字 数目。\n\n如果一个整数相邻数位之间差的绝对值都 恰好 是 1 ，那么这个数字被称为 步进数字 。\n\n请你返回一个整数，表示闭区间 [low, high] 之间步进数字的数目。\n\n由于答案可能很大，请你将它对 109 + 7 取余 后返回。\n\n注意：步进数字不能有前导 0 。\n\n \n\n示例 1：\n\n输入：low = \"1\", high = \"11\"\n输出：10\n解释：区间 [1,11] 内的步进数字为 1 ，2 ，3 ，4 ，5 ，6 ，7 ，8 ，9 和 10 。总共有 10 个步进数字。所以输出为 10 。\n\n示例 2：\n\n输入：low = \"90\", high = \"101\"\n输出：2\n解释：区间 [90,101] 内的步进数字为 98 和 101 。总共有 2 个步进数字。所以输出为 2 。\n\n \n\n提示：\n\n1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow 和 high 只包含数字。\nlow 和 high 都不含前导 0 。"}
{"date": "2023-12-20-16-29", "error": false, "url": "https://leetcode.com/problems/minimum-time-to-make-array-sum-at-most-x", "text_blocks": "给你两个长度相等下标从 0 开始的整数数组 nums1 和 nums2 。每一秒，对于所有下标 0 <= i < nums1.length ，nums1[i] 的值都增加 nums2[i] 。操作 完成后 ，你可以进行如下操作：\n\n选择任一满足 0 <= i < nums1.length 的下标 i ，并使 nums1[i] = 0 。\n\n同时给你一个整数 x 。\n\n请你返回使 nums1 中所有元素之和 小于等于 x 所需要的 最少 时间，如果无法实现，那么返回 -1 。\n\n \n\n示例 1：\n\n输入：nums1 = [1,2,3], nums2 = [1,2,3], x = 4\n输出：3\n解释：\n第 1 秒，我们对 i = 0 进行操作，得到 nums1 = [0,2+2,3+3] = [0,4,6] 。\n第 2 秒，我们对 i = 1 进行操作，得到 nums1 = [0+1,0,6+3] = [1,0,9] 。\n第 3 秒，我们对 i = 2 进行操作，得到 nums1 = [1+1,0+2,0] = [2,2,0] 。\n现在 nums1 的和为 4 。不存在更少次数的操作，所以我们返回 3 。\n\n\n示例 2：\n\n输入：nums1 = [1,2,3], nums2 = [3,3,3], x = 4\n输出：-1\n解释：不管如何操作，nums1 的和总是会超过 x 。\n\n\n \n\n提示：\n\n1 <= nums1.length <= 103\n1 <= nums1[i] <= 103\n0 <= nums2[i] <= 103\nnums1.length == nums2.length\n0 <= x <= 106"}
{"date": "2023-12-20-16-29", "error": false, "url": "https://leetcode.com/problems/maximum-elegance-of-a-k-length-subsequence", "text_blocks": "给你一个长度为 n 的二维整数数组 items 和一个整数 k 。\n\nitems[i] = [profiti, categoryi]，其中 profiti 和 categoryi 分别表示第 i 个项目的利润和类别。\n\n现定义 items 的 子序列 的 优雅度 可以用 total_profit + distinct_categories2 计算，其中 total_profit 是子序列中所有项目的利润总和，distinct_categories 是所选子序列所含的所有类别中不同类别的数量。\n\n你的任务是从 items 所有长度为 k 的子序列中，找出 最大优雅度 。\n\n用整数形式表示并返回 items 中所有长度恰好为 k 的子序列的最大优雅度。\n\n注意：数组的子序列是经由原数组删除一些元素（可能不删除）而产生的新数组，且删除不改变其余元素相对顺序。\n\n \n\n示例 1：\n\n输入：items = [[3,2],[5,1],[10,1]], k = 2\n输出：17\n解释：\n在这个例子中，我们需要选出长度为 2 的子序列。\n其中一种方案是 items[0] = [3,2] 和 items[2] = [10,1] 。\n子序列的总利润为 3 + 10 = 13 ，子序列包含 2 种不同类别 [2,1] 。\n因此，优雅度为 13 + 22 = 17 ，可以证明 17 是可以获得的最大优雅度。 \n\n\n示例 2：\n\n输入：items = [[3,1],[3,1],[2,2],[5,3]], k = 3\n输出：19\n解释：\n在这个例子中，我们需要选出长度为 3 的子序列。 \n其中一种方案是 items[0] = [3,1] ，items[2] = [2,2] 和 items[3] = [5,3] 。\n子序列的总利润为 3 + 2 + 5 = 10 ，子序列包含 3 种不同类别 [1, 2, 3] 。 \n因此，优雅度为 10 + 32 = 19 ，可以证明 19 是可以获得的最大优雅度。\n\n示例 3：\n\n输入：items = [[1,1],[2,1],[3,1]], k = 3\n输出：7\n解释：\n在这个例子中，我们需要选出长度为 3 的子序列。\n我们需要选中所有项目。\n子序列的总利润为 1 + 2 + 3 = 6，子序列包含 1 种不同类别 [1] 。\n因此，最大优雅度为 6 + 12 = 7 。\n\n \n\n提示：\n\n1 <= items.length == n <= 105\nitems[i].length == 2\nitems[i][0] == profiti\nitems[i][1] == categoryi\n1 <= profiti <= 109\n1 <= categoryi <= n \n1 <= k <= n"}
{"date": "2023-12-20-16-29", "error": false, "url": "https://leetcode.com/problems/apply-operations-to-maximize-score", "text_blocks": "给你一个长度为 n 的正整数数组 nums 和一个整数 k 。\n\n一开始，你的分数为 1 。你可以进行以下操作至多 k 次，目标是使你的分数最大：\n\n选择一个之前没有选过的 非空 子数组 nums[l, ..., r] 。\n从 nums[l, ..., r] 里面选择一个 质数分数 最高的元素 x 。如果多个元素质数分数相同且最高，选择下标最小的一个。\n将你的分数乘以 x 。\n\nnums[l, ..., r] 表示 nums 中起始下标为 l ，结束下标为 r 的子数组，两个端点都包含。\n\n一个整数的 质数分数 等于 x 不同质因子的数目。比方说， 300 的质数分数为 3 ，因为 300 = 2 * 2 * 3 * 5 * 5 。\n\n请你返回进行至多 k 次操作后，可以得到的 最大分数 。\n\n由于答案可能很大，请你将结果对 109 + 7 取余后返回。\n\n \n\n示例 1：\n\n输入：nums = [8,3,9,3,8], k = 2\n输出：81\n解释：进行以下操作可以得到分数 81 ：\n- 选择子数组 nums[2, ..., 2] 。nums[2] 是子数组中唯一的元素。所以我们将分数乘以 nums[2] ，分数变为 1 * 9 = 9 。\n- 选择子数组 nums[2, ..., 3] 。nums[2] 和 nums[3] 质数分数都为 1 ，但是 nums[2] 下标更小。所以我们将分数乘以 nums[2] ，分数变为 9 * 9 = 81 。\n81 是可以得到的最高得分。\n\n示例 2：\n\n输入：nums = [19,12,14,6,10,18], k = 3\n输出：4788\n解释：进行以下操作可以得到分数 4788 ：\n- 选择子数组 nums[0, ..., 0] 。nums[0] 是子数组中唯一的元素。所以我们将分数乘以 nums[0] ，分数变为 1 * 19 = 19 。\n- 选择子数组 nums[5, ..., 5] 。nums[5] 是子数组中唯一的元素。所以我们将分数乘以 nums[5] ，分数变为 19 * 18 = 342 。\n- 选择子数组 nums[2, ..., 3] 。nums[2] 和 nums[3] 质数分数都为 2，但是 nums[2] 下标更小。所以我们将分数乘以 nums[2] ，分数变为  342 * 14 = 4788 。\n4788 是可以得到的最高的分。\n\n\n \n\n提示：\n\n1 <= nums.length == n <= 105\n1 <= nums[i] <= 105\n1 <= k <= min(n * (n + 1) / 2, 109)"}
{"date": "2023-12-20-16-29", "error": false, "url": "https://leetcode.com/problems/number-of-beautiful-integers-in-the-range", "text_blocks": "给你正整数 low ，high 和 k 。\n\n如果一个数满足以下两个条件，那么它是 美丽的 ：\n\n偶数数位的数目与奇数数位的数目相同。\n这个整数可以被 k 整除。\n\n请你返回范围 [low, high] 中美丽整数的数目。\n\n \n\n示例 1：\n\n输入：low = 10, high = 20, k = 3\n输出：2\n解释：给定范围中有 2 个美丽数字：[12,18]\n- 12 是美丽整数，因为它有 1 个奇数数位和 1 个偶数数位，而且可以被 k = 3 整除。\n- 18 是美丽整数，因为它有 1 个奇数数位和 1 个偶数数位，而且可以被 k = 3 整除。\n以下是一些不是美丽整数的例子：\n- 16 不是美丽整数，因为它不能被 k = 3 整除。\n- 15 不是美丽整数，因为它的奇数数位和偶数数位的数目不相等。\n给定范围内总共有 2 个美丽整数。\n\n\n示例 2：\n\n输入：low = 1, high = 10, k = 1\n输出：1\n解释：给定范围中有 1 个美丽数字：[10]\n- 10 是美丽整数，因为它有 1 个奇数数位和 1 个偶数数位，而且可以被 k = 1 整除。\n给定范围内总共有 1 个美丽整数。\n\n\n示例 3：\n\n输入：low = 5, high = 5, k = 2\n输出：0\n解释：给定范围中有 0 个美丽数字。\n- 5 不是美丽整数，因为它的奇数数位和偶数数位的数目不相等。\n\n\n \n\n提示：\n\n0 < low <= high <= 109\n0 < k <= 20"}
{"date": "2023-12-20-16-29", "error": false, "url": "https://leetcode.com/problems/minimum-operations-to-form-subsequence-with-target-sum", "text_blocks": "给你一个下标从 0 开始的数组 nums ，它包含 非负 整数，且全部为 2 的幂，同时给你一个整数 target 。\n\n一次操作中，你必须对数组做以下修改：\n\n选择数组中一个元素 nums[i] ，满足 nums[i] > 1 。\n将 nums[i] 从数组中删除。\n在 nums 的 末尾 添加 两个 数，值都为 nums[i] / 2 。\n\n你的目标是让 nums 的一个 子序列 的元素和等于 target ，请你返回达成这一目标的 最少操作次数 。如果无法得到这样的子序列，请你返回 -1 。\n\n数组中一个 子序列 是通过删除原数组中一些元素，并且不改变剩余元素顺序得到的剩余数组。\n\n \n\n示例 1：\n\n输入：nums = [1,2,8], target = 7\n输出：1\n解释：第一次操作中，我们选择元素 nums[2] 。数组变为 nums = [1,2,4,4] 。\n这时候，nums 包含子序列 [1,2,4] ，和为 7 。\n无法通过更少的操作得到和为 7 的子序列。\n\n\n示例 2：\n\n输入：nums = [1,32,1,2], target = 12\n输出：2\n解释：第一次操作中，我们选择元素 nums[1] 。数组变为 nums = [1,1,2,16,16] 。\n第二次操作中，我们选择元素 nums[3] 。数组变为 nums = [1,1,2,16,8,8] 。\n这时候，nums 包含子序列 [1,1,2,8] ，和为 12 。\n无法通过更少的操作得到和为 12 的子序列。\n\n示例 3：\n\n输入：nums = [1,32,1], target = 35\n输出：-1\n解释：无法得到和为 35 的子序列。\n\n\n \n\n提示：\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 230\nnums 只包含非负整数，且均为 2 的幂。\n1 <= target < 231"}
{"date": "2023-12-20-16-29", "error": false, "url": "https://leetcode.com/problems/maximize-value-of-function-in-a-ball-passing-game", "text_blocks": "给你一个长度为 n 下标从 0 开始的整数数组 receiver 和一个整数 k 。\n\n总共有 n 名玩家，玩家 编号 互不相同，且为 [0, n - 1] 中的整数。这些玩家玩一个传球游戏，receiver[i] 表示编号为 i 的玩家会传球给编号为 receiver[i] 的玩家。玩家可以传球给自己，也就是说 receiver[i] 可能等于 i 。\n\n你需要从 n 名玩家中选择一名玩家作为游戏开始时唯一手中有球的玩家，球会被传 恰好 k 次。\n\n如果选择编号为 x 的玩家作为开始玩家，定义函数 f(x) 表示从编号为 x 的玩家开始，k 次传球内所有接触过球玩家的编号之 和 ，如果有玩家多次触球，则 累加多次 。换句话说， f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver(k)[x] 。\n\n你的任务时选择开始玩家 x ，目的是 最大化 f(x) 。\n\n请你返回函数的 最大值 。\n\n注意：receiver 可能含有重复元素。\n\n \n\n示例 1：\n\n传递次数\t传球者编号\t接球者编号\tx + 所有接球者编号\n \t \t \t2\n1\t2\t1\t3\n2\t1\t0\t3\n3\t0\t2\t5\n4\t2\t1\t6\n\n \n\n输入：receiver = [2,0,1], k = 4\n输出：6\n解释：上表展示了从编号为 x = 2 开始的游戏过程。\n从表中可知，f(2) 等于 6 。\n6 是能得到最大的函数值。\n所以输出为 6 。\n\n\n示例 2：\n\n传递次数\t传球者编号\t接球者编号\tx + 所有接球者编号\n \t \t \t4\n1\t4\t3\t7\n2\t3\t2\t9\n3\t2\t1\t10\n\n \n\n输入：receiver = [1,1,1,2,3], k = 3\n输出：10\n解释：上表展示了从编号为 x = 4 开始的游戏过程。\n从表中可知，f(4) 等于 10 。\n10 是能得到最大的函数值。\n所以输出为 10 。\n\n\n \n\n提示：\n\n1 <= receiver.length == n <= 105\n0 <= receiver[i] <= n - 1\n1 <= k <= 1010"}
{"date": "2023-12-20-16-29", "error": false, "url": "https://leetcode.com/problems/count-k-subsequences-of-a-string-with-maximum-beauty", "text_blocks": "给你一个字符串 s 和一个整数 k 。\n\nk 子序列指的是 s 的一个长度为 k 的 子序列 ，且所有字符都是 唯一 的，也就是说每个字符在子序列里只出现过一次。\n\n定义 f(c) 为字符 c 在 s 中出现的次数。\n\nk 子序列的 美丽值 定义为这个子序列中每一个字符 c 的 f(c) 之 和 。\n\n比方说，s = \"abbbdd\" 和 k = 2 ，我们有：\n\nf('a') = 1, f('b') = 3, f('d') = 2\ns 的部分 k 子序列为：\n\"abbbdd\" -> \"ab\" ，美丽值为 f('a') + f('b') = 4\n\"abbbdd\" -> \"ad\" ，美丽值为 f('a') + f('d') = 3\n\"abbbdd\" -> \"bd\" ，美丽值为 f('b') + f('d') = 5\n\n请你返回一个整数，表示所有 k 子序列 里面 美丽值 是 最大值 的子序列数目。由于答案可能很大，将结果对 109 + 7 取余后返回。\n\n一个字符串的子序列指的是从原字符串里面删除一些字符（也可能一个字符也不删除），不改变剩下字符顺序连接得到的新字符串。\n\n注意：\n\nf(c) 指的是字符 c 在字符串 s 的出现次数，不是在 k 子序列里的出现次数。\n两个 k 子序列如果有任何一个字符在原字符串中的下标不同，则它们是两个不同的子序列。所以两个不同的 k 子序列可能产生相同的字符串。\n\n \n\n示例 1：\n\n输入：s = \"bcca\", k = 2\n输出：4\n解释：s 中我们有 f('a') = 1 ，f('b') = 1 和 f('c') = 2 。\ns 的 k 子序列为：\nbcca ，美丽值为 f('b') + f('c') = 3\nbcca ，美丽值为 f('b') + f('c') = 3\nbcca ，美丽值为 f('b') + f('a') = 2\nbcca ，美丽值为 f('c') + f('a') = 3\nbcca ，美丽值为 f('c') + f('a') = 3\n总共有 4 个 k 子序列美丽值为最大值 3 。\n所以答案为 4 。\n\n\n示例 2：\n\n输入：s = \"abbcd\", k = 4\n输出：2\n解释：s 中我们有 f('a') = 1 ，f('b') = 2 ，f('c') = 1 和 f('d') = 1 。\ns 的 k 子序列为：\nabbcd ，美丽值为 f('a') + f('b') + f('c') + f('d') = 5\nabbcd ，美丽值为 f('a') + f('b') + f('c') + f('d') = 5 \n总共有 2 个 k 子序列美丽值为最大值 5 。\n所以答案为 2 。\n\n\n \n\n提示：\n\n1 <= s.length <= 2 * 105\n1 <= k <= s.length\ns 只包含小写英文字母。"}
{"date": "2023-12-20-16-29", "error": false, "url": "https://leetcode.com/problems/minimum-edge-weight-equilibrium-queries-in-a-tree", "text_blocks": "现有一棵由 n 个节点组成的无向树，节点按从 0 到 n - 1 编号。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ui, vi, wi] 表示树中存在一条位于节点 ui 和节点 vi 之间、权重为 wi 的边。\n\n另给你一个长度为 m 的二维整数数组 queries ，其中 queries[i] = [ai, bi] 。对于每条查询，请你找出使从 ai 到 bi 路径上每条边的权重相等所需的 最小操作次数 。在一次操作中，你可以选择树上的任意一条边，并将其权重更改为任意值。\n\n注意：\n\n查询之间 相互独立 的，这意味着每条新的查询时，树都会回到 初始状态 。\n从 ai 到 bi的路径是一个由 不同 节点组成的序列，从节点 ai 开始，到节点 bi 结束，且序列中相邻的两个节点在树中共享一条边。\n\n返回一个长度为 m 的数组 answer ，其中 answer[i] 是第 i 条查询的答案。\n\n \n\n示例 1：\n\n输入：n = 7, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]], queries = [[0,3],[3,6],[2,6],[0,6]]\n输出：[0,0,1,3]\n解释：第 1 条查询，从节点 0 到节点 3 的路径中的所有边的权重都是 1 。因此，答案为 0 。\n第 2 条查询，从节点 3 到节点 6 的路径中的所有边的权重都是 2 。因此，答案为 0 。\n第 3 条查询，将边 [2,3] 的权重变更为 2 。在这次操作之后，从节点 2 到节点 6 的路径中的所有边的权重都是 2 。因此，答案为 1 。\n第 4 条查询，将边 [0,1]、[1,2]、[2,3] 的权重变更为 2 。在这次操作之后，从节点 0 到节点 6 的路径中的所有边的权重都是 2 。因此，答案为 3 。\n对于每条查询 queries[i] ，可以证明 answer[i] 是使从 ai 到 bi 的路径中的所有边的权重相等的最小操作次数。\n\n\n示例 2：\n\n输入：n = 8, edges = [[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]], queries = [[4,6],[0,4],[6,5],[7,4]]\n输出：[1,2,2,3]\n解释：第 1 条查询，将边 [1,3] 的权重变更为 6 。在这次操作之后，从节点 4 到节点 6 的路径中的所有边的权重都是 6 。因此，答案为 1 。\n第 2 条查询，将边 [0,3]、[3,1] 的权重变更为 6 。在这次操作之后，从节点 0 到节点 4 的路径中的所有边的权重都是 6 。因此，答案为 2 。\n第 3 条查询，将边 [1,3]、[5,2] 的权重变更为 6 。在这次操作之后，从节点 6 到节点 5 的路径中的所有边的权重都是 6 。因此，答案为 2 。\n第 4 条查询，将边 [0,7]、[0,3]、[1,3] 的权重变更为 6 。在这次操作之后，从节点 7 到节点 4 的路径中的所有边的权重都是 6 。因此，答案为 3 。\n对于每条查询 queries[i] ，可以证明 answer[i] 是使从 ai 到 bi 的路径中的所有边的权重相等的最小操作次数。 \n\n\n \n\n提示：\n\n1 <= n <= 104\nedges.length == n - 1\nedges[i].length == 3\n0 <= ui, vi < n\n1 <= wi <= 26\n生成的输入满足 edges 表示一棵有效的树\n1 <= queries.length == m <= 2 * 104\nqueries[i].length == 2\n0 <= ai, bi < n"}
{"date": "2023-12-20-16-30", "error": false, "url": "https://leetcode.com/problems/string-transformation", "text_blocks": "给你两个长度都为 n 的字符串 s 和 t 。你可以对字符串 s 执行以下操作：\n\n将 s 长度为 l （0 < l < n）的 后缀字符串 删除，并将它添加在 s 的开头。\n比方说，s = 'abcd' ，那么一次操作中，你可以删除后缀 'cd' ，并将它添加到 s 的开头，得到 s = 'cdab' 。\n\n给你一个整数 k ，请你返回 恰好 k 次操作将 s 变为 t 的方案数。\n\n由于答案可能很大，返回答案对 109 + 7 取余 后的结果。\n\n \n\n示例 1：\n\n输入：s = \"abcd\", t = \"cdab\", k = 2\n输出：2\n解释：\n第一种方案：\n第一次操作，选择 index = 3 开始的后缀，得到 s = \"dabc\" 。\n第二次操作，选择 index = 3 开始的后缀，得到 s = \"cdab\" 。\n\n第二种方案：\n第一次操作，选择 index = 1 开始的后缀，得到 s = \"bcda\" 。\n第二次操作，选择 index = 1 开始的后缀，得到 s = \"cdab\" 。\n\n\n示例 2：\n\n输入：s = \"ababab\", t = \"ababab\", k = 1\n输出：2\n解释：\n第一种方案：\n选择 index = 2 开始的后缀，得到 s = \"ababab\" 。\n\n第二种方案：\n选择 index = 4 开始的后缀，得到 s = \"ababab\" 。\n\n\n \n\n提示：\n\n2 <= s.length <= 5 * 105\n1 <= k <= 1015\ns.length == t.length\ns 和 t 都只包含小写英文字母。"}
{"date": "2023-12-20-16-30", "error": false, "url": "https://leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable", "text_blocks": "给你一个 n 个点的 简单有向图 （没有重复边的有向图），节点编号为 0 到 n - 1 。如果这些边是双向边，那么这个图形成一棵 树 。\n\n给你一个整数 n 和一个 二维 整数数组 edges ，其中 edges[i] = [ui, vi] 表示从节点 ui 到节点 vi 有一条 有向边 。\n\n边反转 指的是将一条边的方向反转，也就是说一条从节点 ui 到节点 vi 的边会变为一条从节点 vi 到节点 ui 的边。\n\n对于范围 [0, n - 1] 中的每一个节点 i ，你的任务是分别 独立 计算 最少 需要多少次 边反转 ，从节点 i 出发经过 一系列有向边 ，可以到达所有的节点。\n\n请你返回一个长度为 n 的整数数组 answer ，其中 answer[i]表示从节点 i 出发，可以到达所有节点的 最少边反转 次数。\n\n \n\n示例 1：\n\n输入：n = 4, edges = [[2,0],[2,1],[1,3]]\n输出：[1,1,0,2]\n解释：上图表示了与输入对应的简单有向图。\n对于节点 0 ：反转 [2,0] ，从节点 0 出发可以到达所有节点。\n所以 answer[0] = 1 。\n对于节点 1 ：反转 [2,1] ，从节点 1 出发可以到达所有节点。\n所以 answer[1] = 1 。\n对于节点 2 ：不需要反转就可以从节点 2 出发到达所有节点。\n所以 answer[2] = 0 。\n对于节点 3 ：反转 [1,3] 和 [2,1] ，从节点 3 出发可以到达所有节点。\n所以 answer[3] = 2 。\n\n\n示例 2：\n\n输入：n = 3, edges = [[1,2],[2,0]]\n输出：[2,0,1]\n解释：上图表示了与输入对应的简单有向图。\n对于节点 0 ：反转 [2,0] 和 [1,2] ，从节点 0 出发可以到达所有节点。\n所以 answer[0] = 2 。\n对于节点 1 ：不需要反转就可以从节点 2 出发到达所有节点。\n所以 answer[1] = 0 。\n对于节点 2 ：反转 [1,2] ，从节点 2 出发可以到达所有节点。\n所以 answer[2] = 1 。\n\n\n \n\n提示：\n\n2 <= n <= 105\nedges.length == n - 1\nedges[i].length == 2\n0 <= ui == edges[i][0] < n\n0 <= vi == edges[i][1] < n\nui != vi\n输入保证如果边是双向边，可以得到一棵树。"}
{"date": "2023-12-20-16-30", "error": false, "url": "https://leetcode.com/problems/maximum-element-sum-of-a-complete-subset-of-indices", "text_blocks": "给你一个下标从 1 开始、由 n 个整数组成的数组。\n\n如果一组数字中每对元素的乘积都是一个完全平方数，则称这组数字是一个 完全集 。\n\n下标集 {1, 2, ..., n} 的子集可以表示为 {i1, i2, ..., ik}，我们定义对应该子集的 元素和 为 nums[i1] + nums[i2] + ... + nums[ik] 。\n\n返回下标集 {1, 2, ..., n} 的 完全子集 所能取到的 最大元素和 。\n\n完全平方数是指可以表示为一个整数和其自身相乘的数。\n\n \n\n示例 1：\n\n输入：nums = [8,7,3,5,7,2,4,9]\n输出：16\n解释：除了由单个下标组成的子集之外，还有两个下标集的完全子集：{1,4} 和 {2,8} 。\n与下标 1 和 4 对应的元素和等于 nums[1] + nums[4] = 8 + 5 = 13 。\n与下标 2 和 8 对应的元素和等于 nums[2] + nums[8] = 7 + 9 = 16 。\n因此，下标集的完全子集可以取到的最大元素和为 16 。\n\n\n示例 2：\n\n输入：nums = [5,10,3,10,1,13,7,9,4]\n输出：19\n解释：除了由单个下标组成的子集之外，还有四个下标集的完全子集：{1,4}、{1,9}、{2,8}、{4,9} 和 {1,4,9} 。 \n与下标 1 和 4 对应的元素和等于 nums[1] + nums[4] = 5 + 10 = 15 。 \n与下标 1 和 9 对应的元素和等于 nums[1] + nums[9] = 5 + 4 = 9 。 \n与下标 2 和 8 对应的元素和等于 nums[2] + nums[8] = 10 + 9 = 19 。\n与下标 4 和 9 对应的元素和等于 nums[4] + nums[9] = 10 + 4 = 14 。 \n与下标 1、4 和 9 对应的元素和等于 nums[1] + nums[4] + nums[9] = 5 + 10 + 4 = 19 。 \n因此，下标集的完全子集可以取到的最大元素和为 19 。\n\n\n \n\n提示：\n\n1 <= n == nums.length <= 104\n1 <= nums[i] <= 109"}
{"date": "2023-12-20-16-30", "error": false, "url": "https://leetcode.com/problems/count-valid-paths-in-a-tree", "text_blocks": "给你一棵 n 个节点的无向树，节点编号为 1 到 n 。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示节点 ui 和 vi 在树中有一条边。\n\n请你返回树中的 合法路径数目 。\n\n如果在节点 a 到节点 b 之间 恰好有一个 节点的编号是质数，那么我们称路径 (a, b) 是 合法的 。\n\n注意：\n\n路径 (a, b) 指的是一条从节点 a 开始到节点 b 结束的一个节点序列，序列中的节点 互不相同 ，且相邻节点之间在树上有一条边。\n路径 (a, b) 和路径 (b, a) 视为 同一条 路径，且只计入答案 一次 。\n\n \n\n示例 1：\n\n输入：n = 5, edges = [[1,2],[1,3],[2,4],[2,5]]\n输出：4\n解释：恰好有一个质数编号的节点路径有：\n- (1, 2) 因为路径 1 到 2 只包含一个质数 2 。\n- (1, 3) 因为路径 1 到 3 只包含一个质数 3 。\n- (1, 4) 因为路径 1 到 4 只包含一个质数 2 。\n- (2, 4) 因为路径 2 到 4 只包含一个质数 2 。\n只有 4 条合法路径。\n\n\n示例 2：\n\n输入：n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]]\n输出：6\n解释：恰好有一个质数编号的节点路径有：\n- (1, 2) 因为路径 1 到 2 只包含一个质数 2 。\n- (1, 3) 因为路径 1 到 3 只包含一个质数 3 。\n- (1, 4) 因为路径 1 到 4 只包含一个质数 2 。\n- (1, 6) 因为路径 1 到 6 只包含一个质数 3 。\n- (2, 4) 因为路径 2 到 4 只包含一个质数 2 。\n- (3, 6) 因为路径 3 到 6 只包含一个质数 3 。\n只有 6 条合法路径。\n\n\n \n\n提示：\n\n1 <= n <= 105\nedges.length == n - 1\nedges[i].length == 2\n1 <= ui, vi <= n\n输入保证 edges 形成一棵合法的树。"}
{"date": "2023-12-20-16-30", "error": false, "url": "https://leetcode.com/problems/maximum-number-of-k-divisible-components", "text_blocks": "给你一棵 n 个节点的无向树，节点编号为 0 到 n - 1 。给你整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 有一条边。\n\n同时给你一个下标从 0 开始长度为 n 的整数数组 values ，其中 values[i] 是第 i 个节点的 值 。再给你一个整数 k 。\n\n你可以从树中删除一些边，也可以一条边也不删，得到若干连通块。一个 连通块的值 定义为连通块中所有节点值之和。如果所有连通块的值都可以被 k 整除，那么我们说这是一个 合法分割 。\n\n请你返回所有合法分割中，连通块数目的最大值 。\n\n \n\n示例 1：\n\n输入：n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6\n输出：2\n解释：我们删除节点 1 和 2 之间的边。这是一个合法分割，因为：\n- 节点 1 和 3 所在连通块的值为 values[1] + values[3] = 12 。\n- 节点 0 ，2 和 4 所在连通块的值为 values[0] + values[2] + values[4] = 6 。\n最多可以得到 2 个连通块的合法分割。\n\n示例 2：\n\n输入：n = 7, edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [3,0,6,1,5,2,1], k = 3\n输出：3\n解释：我们删除节点 0 和 2 ，以及节点 0 和 1 之间的边。这是一个合法分割，因为：\n- 节点 0 的连通块的值为 values[0] = 3 。\n- 节点 2 ，5 和 6 所在连通块的值为 values[2] + values[5] + values[6] = 9 。\n- 节点 1 ，3 和 4 的连通块的值为 values[1] + values[3] + values[4] = 6 。\n最多可以得到 3 个连通块的合法分割。\n\n\n \n\n提示：\n\n1 <= n <= 3 * 104\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi < n\nvalues.length == n\n0 <= values[i] <= 109\n1 <= k <= 109\nvalues 之和可以被 k 整除。\n输入保证 edges 是一棵无向树。"}
{"date": "2023-12-20-16-30", "error": false, "url": "https://leetcode.com/problems/count-visited-nodes-in-a-directed-graph", "text_blocks": "现有一个有向图，其中包含 n 个节点，节点编号从 0 到 n - 1 。此外，该图还包含了 n 条有向边。\n\n给你一个下标从 0 开始的数组 edges ，其中 edges[i] 表示存在一条从节点 i 到节点 edges[i] 的边。\n\n想象在图上发生以下过程：\n\n你从节点 x 开始，通过边访问其他节点，直到你在 此过程 中再次访问到之前已经访问过的节点。\n\n返回数组 answer 作为答案，其中 answer[i] 表示如果从节点 i 开始执行该过程，你可以访问到的不同节点数。\n\n \n\n示例 1：\n\n输入：edges = [1,2,0,0]\n输出：[3,3,3,4]\n解释：从每个节点开始执行该过程，记录如下：\n- 从节点 0 开始，访问节点 0 -> 1 -> 2 -> 0 。访问的不同节点数是 3 。\n- 从节点 1 开始，访问节点 1 -> 2 -> 0 -> 1 。访问的不同节点数是 3 。\n- 从节点 2 开始，访问节点 2 -> 0 -> 1 -> 2 。访问的不同节点数是 3 。\n- 从节点 3 开始，访问节点 3 -> 0 -> 1 -> 2 -> 0 。访问的不同节点数是 4 。\n\n\n示例 2：\n\n输入：edges = [1,2,3,4,0]\n输出：[5,5,5,5,5]\n解释：无论从哪个节点开始，在这个过程中，都可以访问到图中的每一个节点。\n\n\n \n\n提示：\n\nn == edges.length\n2 <= n <= 105\n0 <= edges[i] <= n - 1\nedges[i] != i"}
{"date": "2023-12-20-16-30", "error": false, "url": "https://leetcode.com/problems/apply-operations-on-array-to-maximize-sum-of-squares", "text_blocks": "给你一个下标从 0 开始的整数数组 nums 和一个 正 整数 k 。\n\n你可以对数组执行以下操作 任意次 ：\n\n选择两个互不相同的下标 i 和 j ，同时 将 nums[i] 更新为 (nums[i] AND nums[j]) 且将 nums[j] 更新为 (nums[i] OR nums[j]) ，OR 表示按位 或 运算，AND 表示按位 与 运算。\n\n你需要从最终的数组里选择 k 个元素，并计算它们的 平方 之和。\n\n请你返回你可以得到的 最大 平方和。\n\n由于答案可能会很大，将答案对 109 + 7 取余 后返回。\n\n \n\n示例 1：\n\n输入：nums = [2,6,5,8], k = 2\n输出：261\n解释：我们可以对数组执行以下操作：\n- 选择 i = 0 和 j = 3 ，同时将 nums[0] 变为 (2 AND 8) = 0 且 nums[3] 变为 (2 OR 8) = 10 ，结果数组为 nums = [0,6,5,10] 。\n- 选择 i = 2 和 j = 3 ，同时将 nums[2] 变为 (5 AND 10) = 0 且 nums[3] 变为 (5 OR 10) = 15 ，结果数组为 nums = [0,6,0,15] 。\n从最终数组里选择元素 15 和 6 ，平方和为 152 + 62 = 261 。\n261 是可以得到的最大结果。\n\n\n示例 2：\n\n输入：nums = [4,5,4,7], k = 3\n输出：90\n解释：不需要执行任何操作。\n选择元素 7 ，5 和 4 ，平方和为 72 + 52 + 42 = 90 。\n90 是可以得到的最大结果。\n\n\n \n\n提示：\n\n1 <= k <= nums.length <= 105\n1 <= nums[i] <= 109"}
{"date": "2023-12-20-16-30", "error": false, "url": "https://leetcode.com/problems/count-of-sub-multisets-with-bounded-sum", "text_blocks": "给你一个下标从 0 开始的非负整数数组 nums 和两个整数 l 和 r 。\n\n请你返回 nums 中子多重集合的和在闭区间 [l, r] 之间的 子多重集合的数目 。\n\n由于答案可能很大，请你将答案对 109 + 7 取余后返回。\n\n子多重集合 指的是从数组中选出一些元素构成的 无序 集合，每个元素 x 出现的次数可以是 0, 1, ..., occ[x] 次，其中 occ[x] 是元素 x 在数组中的出现次数。\n\n注意：\n\n如果两个子多重集合中的元素排序后一模一样，那么它们两个是相同的 子多重集合 。\n空 集合的和是 0 。\n\n \n\n示例 1：\n\n输入：nums = [1,2,2,3], l = 6, r = 6\n输出：1\n解释：唯一和为 6 的子集合是 {1, 2, 3} 。\n\n\n示例 2：\n\n输入：nums = [2,1,4,2,7], l = 1, r = 5\n输出：7\n解释：和在闭区间 [1, 5] 之间的子多重集合为 {1} ，{2} ，{4} ，{2, 2} ，{1, 2} ，{1, 4} 和 {1, 2, 2} 。\n\n\n示例 3：\n\n输入：nums = [1,2,1,3,5,2], l = 3, r = 5\n输出：9\n解释：和在闭区间 [3, 5] 之间的子多重集合为 {3} ，{5} ，{1, 2} ，{1, 3} ，{2, 2} ，{2, 3} ，{1, 1, 2} ，{1, 1, 3} 和 {1, 2, 2} 。\n\n \n\n提示：\n\n1 <= nums.length <= 2 * 104\n0 <= nums[i] <= 2 * 104\nnums 的和不超过 2 * 104 。\n0 <= l <= r <= 2 * 104"}
{"date": "2023-12-20-16-30", "error": false, "url": "https://leetcode.com/problems/minimum-changes-to-make-k-semi-palindromes", "text_blocks": "给你一个字符串 s 和一个整数 k ，请你将 s 分成 k 个 子字符串 ，使得每个 子字符串 变成 半回文串 需要修改的字符数目最少。\n\n请你返回一个整数，表示需要修改的 最少 字符数目。\n\n注意：\n\n如果一个字符串从左往右和从右往左读是一样的，那么它是一个 回文串 。\n如果长度为 len 的字符串存在一个满足 1 <= d < len 的正整数 d ，len % d == 0 成立且所有对 d 做除法余数相同的下标对应的字符连起来得到的字符串都是 回文串 ，那么我们说这个字符串是 半回文串 。比方说 \"aa\" ，\"aba\" ，\"adbgad\" 和 \"abab\" 都是 半回文串 ，而 \"a\" ，\"ab\" 和 \"abca\" 不是。\n子字符串 指的是一个字符串中一段连续的字符序列。\n\n \n\n示例 1：\n\n输入：s = \"abcac\", k = 2\n输出：1\n解释：我们可以将 s 分成子字符串 \"ab\" 和 \"cac\" 。子字符串 \"cac\" 已经是半回文串。如果我们将 \"ab\" 变成 \"aa\" ，它也会变成一个 d = 1 的半回文串。\n该方案是将 s 分成 2 个子字符串的前提下，得到 2 个半回文子字符串需要的最少修改次数。所以答案为 1 。\n\n示例 2:\n\n输入：s = \"abcdef\", k = 2\n输出：2\n解释：我们可以将 s 分成子字符串 \"abc\" 和 \"def\" 。子字符串 \"abc\" 和 \"def\" 都需要修改一个字符得到半回文串，所以我们总共需要 2 次字符修改使所有子字符串变成半回文串。\n该方案是将 s 分成 2 个子字符串的前提下，得到 2 个半回文子字符串需要的最少修改次数。所以答案为 2 。\n\n示例 3：\n\n输入：s = \"aabbaa\", k = 3\n输出：0\n解释：我们可以将 s 分成子字符串 \"aa\" ，\"bb\" 和 \"aa\" 。\n字符串 \"aa\" 和 \"bb\" 都已经是半回文串了。所以答案为 0 。\n\n\n \n\n提示：\n\n2 <= s.length <= 200\n1 <= k <= s.length / 2\ns 只包含小写英文字母。"}
{"date": "2023-12-20-16-31", "error": false, "url": "https://leetcode.com/problems/subarrays-distinct-element-sum-of-squares-ii", "text_blocks": "给你一个下标从 0 开始的整数数组 nums 。\n\n定义 nums 一个子数组的 不同计数 值如下：\n\n令 nums[i..j] 表示 nums 中所有下标在 i 到 j 范围内的元素构成的子数组（满足 0 <= i <= j < nums.length ），那么我们称子数组 nums[i..j] 中不同值的数目为 nums[i..j] 的不同计数。\n\n请你返回 nums 中所有子数组的 不同计数 的 平方 和。\n\n由于答案可能会很大，请你将它对 109 + 7 取余 后返回。\n\n子数组指的是一个数组里面一段连续 非空 的元素序列。\n\n \n\n示例 1：\n\n输入：nums = [1,2,1]\n输出：15\n解释：六个子数组分别为：\n[1]: 1 个互不相同的元素。\n[2]: 1 个互不相同的元素。\n[1]: 1 个互不相同的元素。\n[1,2]: 2 个互不相同的元素。\n[2,1]: 2 个互不相同的元素。\n[1,2,1]: 2 个互不相同的元素。\n所有不同计数的平方和为 12 + 12 + 12 + 22 + 22 + 22 = 15 。\n\n\n示例 2：\n\n输入：nums = [2,2]\n输出：3\n解释：三个子数组分别为：\n[2]: 1 个互不相同的元素。\n[2]: 1 个互不相同的元素。\n[2,2]: 1 个互不相同的元素。\n所有不同计数的平方和为 12 + 12 + 12 = 3 。\n\n\n \n\n提示：\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105"}
{"date": "2023-12-20-16-31", "error": false, "url": "https://leetcode.com/problems/maximum-points-after-collecting-coins-from-all-nodes", "text_blocks": "有一棵由 n 个节点组成的无向树，以 0  为根节点，节点编号从 0 到 n - 1 。给你一个长度为 n - 1 的二维 整数 数组 edges ，其中 edges[i] = [ai, bi] 表示在树上的节点 ai 和 bi 之间存在一条边。另给你一个下标从 0 开始、长度为 n 的数组 coins 和一个整数 k ，其中 coins[i] 表示节点 i 处的金币数量。\n\n从根节点开始，你必须收集所有金币。要想收集节点上的金币，必须先收集该节点的祖先节点上的金币。\n\n节点 i 上的金币可以用下述方法之一进行收集：\n\n收集所有金币，得到共计 coins[i] - k 点积分。如果 coins[i] - k 是负数，你将会失去 abs(coins[i] - k) 点积分。\n收集所有金币，得到共计 floor(coins[i] / 2) 点积分。如果采用这种方法，节点 i 子树中所有节点 j 的金币数 coins[j] 将会减少至 floor(coins[j] / 2) 。\n\n返回收集 所有 树节点的金币之后可以获得的最大积分。\n\n \n\n示例 1：\n\n输入：edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5\n输出：11                        \n解释：\n使用第一种方法收集节点 0 上的所有金币。总积分 = 10 - 5 = 5 。\n使用第一种方法收集节点 1 上的所有金币。总积分 = 5 + (10 - 5) = 10 。\n使用第二种方法收集节点 2 上的所有金币。所以节点 3 上的金币将会变为 floor(3 / 2) = 1 ，总积分 = 10 + floor(3 / 2) = 11 。\n使用第二种方法收集节点 3 上的所有金币。总积分 =  11 + floor(1 / 2) = 11.\n可以证明收集所有节点上的金币能获得的最大积分是 11 。 \n\n\n示例 2：\n\n输入：edges = [[0,1],[0,2]], coins = [8,4,4], k = 0\n输出：16\n解释：\n使用第一种方法收集所有节点上的金币，因此，总积分 = (8 - 0) + (4 - 0) + (4 - 0) = 16 。\n\n\n \n\n提示：\n\nn == coins.length\n2 <= n <= 105\n0 <= coins[i] <= 104\nedges.length == n - 1\n0 <= edges[i][0], edges[i][1] < n\n0 <= k <= 104"}
{"date": "2023-12-20-16-31", "error": false, "url": "https://leetcode.com/problems/maximum-balanced-subsequence-sum", "text_blocks": "给你一个下标从 0 开始的整数数组 nums 。\n\nnums 一个长度为 k 的 子序列 指的是选出 k 个 下标 i0 < i1 < ... < ik-1 ，如果这个子序列满足以下条件，我们说它是 平衡的 ：\n\n对于范围 [1, k - 1] 内的所有 j ，nums[ij] - nums[ij-1] >= ij - ij-1 都成立。\n\nnums 长度为 1 的 子序列 是平衡的。\n\n请你返回一个整数，表示 nums 平衡 子序列里面的 最大元素和 。\n\n一个数组的 子序列 指的是从原数组中删除一些元素（也可能一个元素也不删除）后，剩余元素保持相对顺序得到的 非空 新数组。\n\n \n\n示例 1：\n\n输入：nums = [3,3,5,6]\n输出：14\n解释：这个例子中，选择子序列 [3,5,6] ，下标为 0 ，2 和 3 的元素被选中。\nnums[2] - nums[0] >= 2 - 0 。\nnums[3] - nums[2] >= 3 - 2 。\n所以，这是一个平衡子序列，且它的和是所有平衡子序列里最大的。\n包含下标 1 ，2 和 3 的子序列也是一个平衡的子序列。\n最大平衡子序列和为 14 。\n\n示例 2：\n\n输入：nums = [5,-1,-3,8]\n输出：13\n解释：这个例子中，选择子序列 [5,8] ，下标为 0 和 3 的元素被选中。\nnums[3] - nums[0] >= 3 - 0 。\n所以，这是一个平衡子序列，且它的和是所有平衡子序列里最大的。\n最大平衡子序列和为 13 。\n\n\n示例 3：\n\n输入：nums = [-2,-1]\n输出：-1\n解释：这个例子中，选择子序列 [-1] 。\n这是一个平衡子序列，而且它的和是 nums 所有平衡子序列里最大的。\n\n\n \n\n提示：\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109"}
{"date": "2023-12-20-16-31", "error": false, "url": "https://leetcode.com/problems/maximum-spending-after-buying-items", "text_blocks": "给你一个下标从 0 开始大小为 m * n 的整数矩阵 values ，表示 m 个不同商店里 m * n 件不同的物品。每个商店有 n 件物品，第 i 个商店的第 j 件物品的价值为 values[i][j] 。除此以外，第 i 个商店的物品已经按照价值非递增排好序了，也就是说对于所有 0 <= j < n - 1 都有 values[i][j] >= values[i][j + 1] 。\n\n每一天，你可以在一个商店里购买一件物品。具体来说，在第 d 天，你可以：\n\n选择商店 i 。\n购买数组中最右边的物品 j ，开销为 values[i][j] * d 。换句话说，选择该商店中还没购买过的物品中最大的下标 j ，并且花费 values[i][j] * d 去购买。\n\n注意，所有物品都视为不同的物品。比方说如果你已经从商店 1 购买了物品 0 ，你还可以在别的商店里购买其他商店的物品 0 。\n\n请你返回购买所有 m * n 件物品需要的 最大开销 。\n\n \n\n示例 1：\n\n输入：values = [[8,5,2],[6,4,1],[9,7,3]]\n输出：285\n解释：第一天，从商店 1 购买物品 2 ，开销为 values[1][2] * 1 = 1 。\n第二天，从商店 0 购买物品 2 ，开销为 values[0][2] * 2 = 4 。\n第三天，从商店 2 购买物品 2 ，开销为 values[2][2] * 3 = 9 。\n第四天，从商店 1 购买物品 1 ，开销为 values[1][1] * 4 = 16 。\n第五天，从商店 0 购买物品 1 ，开销为 values[0][1] * 5 = 25 。\n第六天，从商店 1 购买物品 0 ，开销为 values[1][0] * 6 = 36 。\n第七天，从商店 2 购买物品 1 ，开销为 values[2][1] * 7 = 49 。\n第八天，从商店 0 购买物品 0 ，开销为 values[0][0] * 8 = 64 。\n第九天，从商店 2 购买物品 0 ，开销为 values[2][0] * 9 = 81 。\n所以总开销为 285 。\n285 是购买所有 m * n 件物品的最大总开销。\n\n\n示例 2：\n\n输入：values = [[10,8,6,4,2],[9,7,5,3,2]]\n输出：386\n解释：第一天，从商店 0 购买物品 4 ，开销为 values[0][4] * 1 = 2 。\n第二天，从商店 1 购买物品 4 ，开销为 values[1][4] * 2 = 4 。\n第三天，从商店 1 购买物品 3 ，开销为 values[1][3] * 3 = 9 。\n第四天，从商店 0 购买物品 3 ，开销为 values[0][3] * 4 = 16 。\n第五天，从商店 1 购买物品 2 ，开销为 values[1][2] * 5 = 25 。\n第六天，从商店 0 购买物品 2 ，开销为 values[0][2] * 6 = 36 。\n第七天，从商店 1 购买物品 1 ，开销为 values[1][1] * 7 = 49 。\n第八天，从商店 0 购买物品 1 ，开销为 values[0][1] * 8 = 64 。\n第九天，从商店 1 购买物品 0 ，开销为 values[1][0] * 9 = 81 。\n第十天，从商店 0 购买物品 0 ，开销为 values[0][0] * 10 = 100 。\n所以总开销为 386 。\n386 是购买所有 m * n 件物品的最大总开销。\n\n\n \n\n提示：\n\n1 <= m == values.length <= 10\n1 <= n == values[i].length <= 104\n1 <= values[i][j] <= 106\nvalues[i] 按照非递增顺序排序。"}
{"date": "2023-12-20-16-31", "error": false, "url": "https://leetcode.com/problems/maximum-strong-pair-xor-ii", "text_blocks": "给你一个下标从 0 开始的整数数组 nums 。如果一对整数 x 和 y 满足以下条件，则称其为 强数对 ：\n\n|x - y| <= min(x, y)\n\n你需要从 nums 中选出两个整数，且满足：这两个整数可以形成一个强数对，并且它们的按位异或（XOR）值是在该数组所有强数对中的 最大值 。\n\n返回数组 nums 所有可能的强数对中的 最大 异或值。\n\n注意，你可以选择同一个整数两次来形成一个强数对。\n\n \n\n示例 1：\n\n输入：nums = [1,2,3,4,5]\n输出：7\n解释：数组 nums 中有 11 个强数对：(1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) 和 (5, 5) 。\n这些强数对中的最大异或值是 3 XOR 4 = 7 。\n\n\n示例 2：\n\n输入：nums = [10,100]\n输出：0\n解释：数组 nums 中有 2 个强数对：(10, 10) 和 (100, 100) 。\n这些强数对中的最大异或值是 10 XOR 10 = 0 ，数对 (100, 100) 的异或值也是 100 XOR 100 = 0 。\n\n\n示例 3：\n\n输入：nums = [500,520,2500,3000]\n输出：1020\n解释：数组 nums 中有 6 个强数对：(500, 500), (500, 520), (520, 520), (2500, 2500), (2500, 3000) 和 (3000, 3000) 。\n这些强数对中的最大异或值是 500 XOR 520 = 1020 ；另一个异或值非零的数对是 (5, 6) ，其异或值是 2500 XOR 3000 = 636 。\n\n\n \n\n提示：\n\n1 <= nums.length <= 5 * 104\n1 <= nums[i] <= 220 - 1"}
{"date": "2023-12-20-16-31", "error": false, "url": "https://leetcode.com/problems/find-building-where-alice-and-bob-can-meet", "text_blocks": "给你一个下标从 0 开始的正整数数组 heights ，其中 heights[i] 表示第 i 栋建筑的高度。\n\n如果一个人在建筑 i ，且存在 i < j 的建筑 j 满足 heights[i] < heights[j] ，那么这个人可以移动到建筑 j 。\n\n给你另外一个数组 queries ，其中 queries[i] = [ai, bi] 。第 i 个查询中，Alice 在建筑 ai ，Bob 在建筑 bi 。\n\n请你能返回一个数组 ans ，其中 ans[i] 是第 i 个查询中，Alice 和 Bob 可以相遇的 最左边的建筑 。如果对于查询 i ，Alice 和 Bob 不能相遇，令 ans[i] 为 -1 。\n\n \n\n示例 1：\n\n输入：heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]\n输出：[2,5,-1,5,2]\n解释：第一个查询中，Alice 和 Bob 可以移动到建筑 2 ，因为 heights[0] < heights[2] 且 heights[1] < heights[2] 。\n第二个查询中，Alice 和 Bob 可以移动到建筑 5 ，因为 heights[0] < heights[5] 且 heights[3] < heights[5] 。\n第三个查询中，Alice 无法与 Bob 相遇，因为 Alice 不能移动到任何其他建筑。\n第四个查询中，Alice 和 Bob 可以移动到建筑 5 ，因为 heights[3] < heights[5] 且 heights[4] < heights[5] 。\n第五个查询中，Alice 和 Bob 已经在同一栋建筑中。\n对于 ans[i] != -1 ，ans[i] 是 Alice 和 Bob 可以相遇的建筑中最左边建筑的下标。\n对于 ans[i] == -1 ，不存在 Alice 和 Bob 可以相遇的建筑。\n\n\n示例 2：\n\n输入：heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]\n输出：[7,6,-1,4,6]\n解释：第一个查询中，Alice 可以直接移动到 Bob 的建筑，因为 heights[0] < heights[7] 。\n第二个查询中，Alice 和 Bob 可以移动到建筑 6 ，因为 heights[3] < heights[6] 且 heights[5] < heights[6] 。\n第三个查询中，Alice 无法与 Bob 相遇，因为 Bob 不能移动到任何其他建筑。\n第四个查询中，Alice 和 Bob 可以移动到建筑 4 ，因为 heights[3] < heights[4] 且 heights[0] < heights[4] 。\n第五个查询中，Alice 可以直接移动到 Bob 的建筑，因为 heights[1] < heights[6] 。\n对于 ans[i] != -1 ，ans[i] 是 Alice 和 Bob 可以相遇的建筑中最左边建筑的下标。\n对于 ans[i] == -1 ，不存在 Alice 和 Bob 可以相遇的建筑。\n\n\n \n\n提示：\n\n1 <= heights.length <= 5 * 104\n1 <= heights[i] <= 109\n1 <= queries.length <= 5 * 104\nqueries[i] = [ai, bi]\n0 <= ai, bi <= heights.length - 1"}
{"date": "2023-12-20-16-31", "error": false, "url": "https://leetcode.com/problems/find-maximum-non-decreasing-array-length", "text_blocks": "给你一个下标从 0 开始的整数数组 nums 。\n\n你可以执行任意次操作。每次操作中，你需要选择一个 子数组 ，并将这个子数组用它所包含元素的 和 替换。比方说，给定数组是 [1,3,5,6] ，你可以选择子数组 [3,5] ，用子数组的和 8 替换掉子数组，然后数组会变为 [1,8,6] 。\n\n请你返回执行任意次操作以后，可以得到的 最长非递减 数组的长度。\n\n子数组 指的是一个数组中一段连续 非空 的元素序列。\n\n \n\n示例 1：\n\n输入：nums = [5,2,2]\n输出：1\n解释：这个长度为 3 的数组不是非递减的。\n我们有 2 种方案使数组长度为 2 。\n第一种，选择子数组 [2,2] ，对数组执行操作后得到 [5,4] 。\n第二种，选择子数组 [5,2] ，对数组执行操作后得到 [7,2] 。\n这两种方案中，数组最后都不是 非递减 的，所以不是可行的答案。\n如果我们选择子数组 [5,2,2] ，并将它替换为 [9] ，数组变成非递减的。\n所以答案为 1 。\n\n\n示例 2：\n\n输入：nums = [1,2,3,4]\n输出：4\n解释：数组已经是非递减的。所以答案为 4 。\n\n\n示例 3：\n\n输入：nums = [4,3,2,6]\n输出：3\n解释：将 [3,2] 替换为 [5] ，得到数组 [4,5,6] ，它是非递减的。\n最大可能的答案为 3 。\n\n \n\n提示：\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105"}
{"date": "2023-12-20-16-31", "error": false, "url": "https://leetcode.com/problems/count-beautiful-substrings-ii", "text_blocks": "给你一个字符串 s 和一个正整数 k 。\n\n用 vowels 和 consonants 分别表示字符串中元音字母和辅音字母的数量。\n\n如果某个字符串满足以下条件，则称其为 美丽字符串 ：\n\nvowels == consonants，即元音字母和辅音字母的数量相等。\n(vowels * consonants) % k == 0，即元音字母和辅音字母的数量的乘积能被 k 整除。\n\n返回字符串 s 中 非空美丽子字符串 的数量。\n\n子字符串是字符串中的一个连续字符序列。\n\n英语中的 元音字母 为 'a'、'e'、'i'、'o' 和 'u' 。\n\n英语中的 辅音字母 为除了元音字母之外的所有字母。\n\n \n\n示例 1：\n\n输入：s = \"baeyh\", k = 2\n输出：2\n解释：字符串 s 中有 2 个美丽子字符串。\n- 子字符串 \"baeyh\"，vowels = 2（[\"a\",\"e\"]），consonants = 2（[\"y\",\"h\"]）。\n可以看出字符串 \"aeyh\" 是美丽字符串，因为 vowels == consonants 且 vowels * consonants % k == 0 。\n- 子字符串 \"baeyh\"，vowels = 2（[\"a\",\"e\"]），consonants = 2（[\"b\",\"y\"]）。\n可以看出字符串 \"baey\" 是美丽字符串，因为 vowels == consonants 且 vowels * consonants % k == 0 。\n可以证明字符串 s 中只有 2 个美丽子字符串。\n\n\n示例 2：\n\n输入：s = \"abba\", k = 1\n输出：3\n解释：字符串 s 中有 3 个美丽子字符串。\n- 子字符串 \"abba\"，vowels = 1（[\"a\"]），consonants = 1（[\"b\"]）。\n- 子字符串 \"abba\"，vowels = 1（[\"a\"]），consonants = 1（[\"b\"]）。\n- 子字符串 \"abba\"，vowels = 2（[\"a\",\"a\"]），consonants = 2（[\"b\",\"b\"]）。\n可以证明字符串 s 中只有 3 个美丽子字符串。\n\n\n示例 3：\n\n输入：s = \"bcdf\", k = 1\n输出：0\n解释：字符串 s 中没有美丽子字符串。\n\n\n \n\n提示：\n\n1 <= s.length <= 5 * 104\n1 <= k <= 1000\ns 仅由小写英文字母组成。"}
{"date": "2023-12-20-16-32", "error": false, "url": "https://leetcode.com/problems/count-complete-substrings", "text_blocks": "给你一个字符串 word 和一个整数 k 。\n\n如果 word 的一个子字符串 s 满足以下条件，我们称它是 完全字符串：\n\ns 中每个字符 恰好 出现 k 次。\n相邻字符在字母表中的顺序 至多 相差 2 。也就是说，s 中两个相邻字符 c1 和 c2 ，它们在字母表中的位置相差 至多 为 2 。\n\n请你返回 word 中 完全 子字符串的数目。\n\n子字符串 指的是一个字符串中一段连续 非空 的字符序列。\n\n \n\n示例 1：\n\n输入：word = \"igigee\", k = 2\n输出：3\n解释：完全子字符串需要满足每个字符恰好出现 2 次，且相邻字符相差至多为 2 ：igigee, igigee, igigee 。\n\n\n示例 2：\n\n输入：word = \"aaabbbccc\", k = 3\n输出：6\n解释：完全子字符串需要满足每个字符恰好出现 3 次，且相邻字符相差至多为 2 ：aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc 。\n\n\n \n\n提示：\n\n1 <= word.length <= 105\nword 只包含小写英文字母。\n1 <= k <= word.length"}
{"date": "2023-12-20-16-32", "error": false, "url": "https://leetcode.com/problems/count-the-number-of-infection-sequences", "text_blocks": "给你一个整数 n 和一个下标从 0 开始的整数数组 sick ，数组按 升序 排序。\n\n有 n 位小朋友站成一排，按顺序编号为 0 到 n - 1 。数组 sick 包含一开始得了感冒的小朋友的位置。如果位置为 i 的小朋友得了感冒，他会传染给下标为 i - 1 或者 i + 1 的小朋友，前提 是被传染的小朋友存在且还没有得感冒。每一秒中， 至多一位 还没感冒的小朋友会被传染。\n\n经过有限的秒数后，队列中所有小朋友都会感冒。感冒序列 指的是 所有 一开始没有感冒的小朋友最后得感冒的顺序序列。请你返回所有感冒序列的数目。\n\n由于答案可能很大，请你将答案对 109 + 7 取余后返回。\n\n注意，感冒序列 不 包含一开始就得了感冒的小朋友的下标。\n\n \n\n示例 1：\n\n输入：n = 5, sick = [0,4]\n输出：4\n解释：一开始，下标为 1 ，2 和 3 的小朋友没有感冒。总共有 4 个可能的感冒序列：\n- 一开始，下标为 1 和 3 的小朋友可以被传染，因为他们分别挨着有感冒的小朋友 0 和 4 ，令下标为 1 的小朋友先被传染。\n然后，下标为 2 的小朋友挨着感冒的小朋友 1 ，下标为 3 的小朋友挨着感冒的小朋友 4 ，两位小朋友都可以被传染，令下标为 2 的小朋友被传染。\n最后，下标为 3 的小朋友被传染，因为他挨着感冒的小朋友 2 和 4 ，感冒序列为 [1,2,3] 。\n- 一开始，下标为 1 和 3 的小朋友可以被传染，因为他们分别挨着感冒的小朋友 0 和 4 ，令下标为 1 的小朋友先被传染。\n然后，下标为 2 的小朋友挨着感冒的小朋友 1 ，下标为 3 的小朋友挨着感冒的小朋友 4 ，两位小朋友都可以被传染，令下标为 3 的小朋友被传染。\n最后，下标为 2 的小朋友被传染，因为他挨着感冒的小朋友 1 和 3 ，感冒序列为  [1,3,2] 。\n- 感冒序列 [3,1,2] ，被传染的顺序：[0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] 。\n- 感冒序列 [3,2,1] ，被传染的顺序：[0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] 。\n\n\n示例 2：\n\n输入：n = 4, sick = [1]\n输出：3\n解释：一开始，下标为 0 ，2 和 3 的小朋友没有感冒。总共有 3 个可能的感冒序列：\n- 感冒序列 [0,2,3] ，被传染的顺序：[0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3] 。\n- 感冒序列 [2,0,3] ，被传染的顺序：[0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3] 。\n- 感冒序列 [2,3,0] ，被传染的顺序：[0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3] 。\n\n\n \n\n提示：\n\n2 <= n <= 105\n1 <= sick.length <= n - 1\n0 <= sick[i] <= n - 1\nsick 按升序排列。"}
{"date": "2023-12-20-16-32", "error": false, "url": "https://leetcode.com/problems/number-of-possible-sets-of-closing-branches", "text_blocks": "一个公司在全国有 n 个分部，它们之间有的有道路连接。一开始，所有分部通过这些道路两两之间互相可以到达。\n\n公司意识到在分部之间旅行花费了太多时间，所以它们决定关闭一些分部（也可能不关闭任何分部），同时保证剩下的分部之间两两互相可以到达且最远距离不超过 maxDistance 。\n\n两个分部之间的 距离 是通过道路长度之和的 最小值 。\n\n给你整数 n ，maxDistance 和下标从 0 开始的二维整数数组 roads ，其中 roads[i] = [ui, vi, wi] 表示一条从 ui 到 vi 长度为 wi的 无向 道路。\n\n请你返回关闭分部的可行方案数目，满足每个方案里剩余分部之间的最远距离不超过 maxDistance。\n\n注意，关闭一个分部后，与之相连的所有道路不可通行。\n\n注意，两个分部之间可能会有多条道路。\n\n \n\n示例 1：\n\n输入：n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]\n输出：5\n解释：可行的关闭分部方案有：\n- 关闭分部集合 [2] ，剩余分部为 [0,1] ，它们之间的距离为 2 。\n- 关闭分部集合 [0,1] ，剩余分部为 [2] 。\n- 关闭分部集合 [1,2] ，剩余分部为 [0] 。\n- 关闭分部集合 [0,2] ，剩余分部为 [1] 。\n- 关闭分部集合 [0,1,2] ，关闭后没有剩余分部。\n总共有 5 种可行的关闭方案。\n\n\n示例 2：\n\n输入：n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]\n输出：7\n解释：可行的关闭分部方案有：\n- 关闭分部集合 [] ，剩余分部为 [0,1,2] ，它们之间的最远距离为 4 。\n- 关闭分部集合 [0] ，剩余分部为 [1,2] ，它们之间的距离为 2 。\n- 关闭分部集合 [1] ，剩余分部为 [0,2] ，它们之间的距离为 2 。\n- 关闭分部集合 [0,1] ，剩余分部为 [2] 。\n- 关闭分部集合 [1,2] ，剩余分部为 [0] 。\n- 关闭分部集合 [0,2] ，剩余分部为 [1] 。\n- 关闭分部集合 [0,1,2] ，关闭后没有剩余分部。\n总共有 7 种可行的关闭方案。\n\n\n示例 3：\n\n输入：n = 1, maxDistance = 10, roads = []\n输出：2\n解释：可行的关闭分部方案有：\n- 关闭分部集合 [] ，剩余分部为 [0] 。\n- 关闭分部集合 [0] ，关闭后没有剩余分部。\n总共有 2 种可行的关闭方案。\n\n\n \n\n提示：\n\n1 <= n <= 10\n1 <= maxDistance <= 105\n0 <= roads.length <= 1000\nroads[i].length == 3\n0 <= ui, vi <= n - 1\nui != vi\n1 <= wi <= 1000\n一开始所有分部之间通过道路互相可以到达。"}
{"date": "2023-12-20-16-32", "error": false, "url": "https://leetcode.com/problems/count-the-number-of-good-partitions", "text_blocks": "给你一个下标从 0 开始、由 正整数 组成的数组 nums。\n\n将数组分割成一个或多个 连续 子数组，如果不存在包含了相同数字的两个子数组，则认为是一种 好分割方案 。\n\n返回 nums 的 好分割方案 的 数目。\n\n由于答案可能很大，请返回答案对 109 + 7 取余 的结果。\n\n \n\n示例 1：\n\n输入：nums = [1,2,3,4]\n输出：8\n解释：有 8 种 好分割方案 ：([1], [2], [3], [4]), ([1], [2], [3,4]), ([1], [2,3], [4]), ([1], [2,3,4]), ([1,2], [3], [4]), ([1,2], [3,4]), ([1,2,3], [4]) 和 ([1,2,3,4]) 。\n\n\n示例 2：\n\n输入：nums = [1,1,1,1]\n输出：1\n解释：唯一的 好分割方案 是：([1,1,1,1]) 。\n\n\n示例 3：\n\n输入：nums = [1,2,1,3]\n输出：2\n解释：有 2 种 好分割方案 ：([1,2,1], [3]) 和 ([1,2,1,3]) 。\n\n\n \n\n提示：\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109"}
{"date": "2023-12-20-16-32", "error": false, "url": "https://leetcode.com/problems/apply-operations-to-maximize-frequency-score", "text_blocks": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。\n\n你可以对数组执行 至多 k 次操作：\n\n从数组中选择一个下标 i ，将 nums[i] 增加 或者 减少 1 。\n\n最终数组的频率分数定义为数组中众数的 频率 。\n\n请你返回你可以得到的 最大 频率分数。\n\n众数指的是数组中出现次数最多的数。一个元素的频率指的是数组中这个元素的出现次数。\n\n \n\n示例 1：\n\n输入：nums = [1,2,6,4], k = 3\n输出：3\n解释：我们可以对数组执行以下操作：\n- 选择 i = 0 ，将 nums[0] 增加 1 。得到数组 [2,2,6,4] 。\n- 选择 i = 3 ，将 nums[3] 减少 1 ，得到数组 [2,2,6,3] 。\n- 选择 i = 3 ，将 nums[3] 减少 1 ，得到数组 [2,2,6,2] 。\n元素 2 是最终数组中的众数，出现了 3 次，所以频率分数为 3 。\n3 是所有可行方案里的最大频率分数。\n\n\n示例 2：\n\n输入：nums = [1,4,4,2,4], k = 0\n输出：3\n解释：我们无法执行任何操作，所以得到的频率分数是原数组中众数的频率 3 。\n\n\n \n\n提示：\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n0 <= k <= 1014"}
{"date": "2023-12-20-18-59", "error": false, "url": "https://leetcode.com/problems/greatest-common-divisor-traversal", "text_blocks": "给你一个下标从 0 开始的整数数组 nums ，你可以在一些下标之间遍历。对于两个下标 i 和 j（i != j），当且仅当 gcd(nums[i], nums[j]) > 1 时，我们可以在两个下标之间通行，其中 gcd 是两个数的 最大公约数 。\n\n你需要判断 nums 数组中 任意 两个满足 i < j 的下标 i 和 j ，是否存在若干次通行可以从 i 遍历到 j 。\n\n如果任意满足条件的下标对都可以遍历，那么返回 true ，否则返回 false 。\n\n \n\n示例 1：\n\n输入：nums = [2,3,6]\n输出：true\n解释：这个例子中，总共有 3 个下标对：(0, 1) ，(0, 2) 和 (1, 2) 。\n从下标 0 到下标 1 ，我们可以遍历 0 -> 2 -> 1 ，我们可以从下标 0 到 2 是因为 gcd(nums[0], nums[2]) = gcd(2, 6) = 2 > 1 ，从下标 2 到 1 是因为 gcd(nums[2], nums[1]) = gcd(6, 3) = 3 > 1 。\n从下标 0 到下标 2 ，我们可以直接遍历，因为 gcd(nums[0], nums[2]) = gcd(2, 6) = 2 > 1 。同理，我们也可以从下标 1 到 2 因为 gcd(nums[1], nums[2]) = gcd(3, 6) = 3 > 1 。\n\n\n示例 2：\n\n输入：nums = [3,9,5]\n输出：false\n解释：我们没法从下标 0 到 2 ，所以返回 false 。\n\n\n示例 3：\n\n输入：nums = [4,3,12,8]\n输出：true\n解释：总共有 6 个下标对：(0, 1) ，(0, 2) ，(0, 3) ，(1, 2) ，(1, 3) 和 (2, 3) 。所有下标对之间都存在可行的遍历，所以返回 true 。\n\n\n \n\n提示：\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105"}
{"date": "2023-12-20-18-59", "error": false, "url": "https://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix", "text_blocks": "给你一个下标从 1 开始、大小为 m x n 的整数矩阵 mat，你可以选择任一单元格作为 起始单元格 。\n\n从起始单元格出发，你可以移动到 同一行或同一列 中的任何其他单元格，但前提是目标单元格的值 严格大于 当前单元格的值。\n\n你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。\n\n请你找出从某个单元开始访问矩阵所能访问的 单元格的最大数量 。\n\n返回一个表示可访问单元格最大数量的整数。\n\n \n\n示例 1：\n\n输入：mat = [[3,1],[3,4]]\n输出：2\n解释：上图展示了从第 1 行、第 2 列的单元格开始，可以访问 2 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 2 个单元格，因此答案是 2 。 \n\n\n示例 2：\n\n输入：mat = [[1,1],[1,1]]\n输出：1\n解释：由于目标单元格必须严格大于当前单元格，在本示例中只能访问 1 个单元格。 \n\n\n示例 3：\n\n输入：mat = [[3,1,6],[-9,5,7]]\n输出：4\n解释：上图展示了从第 2 行、第 1 列的单元格开始，可以访问 4 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 4 个单元格，因此答案是 4 。  \n\n\n \n\n提示：\n\nm == mat.length \nn == mat[i].length \n1 <= m, n <= 105\n1 <= m * n <= 105\n-105 <= mat[i][j] <= 105"}
{"date": "2023-12-20-18-59", "error": false, "url": "https://leetcode.com/problems/count-of-integers", "text_blocks": "给你两个数字字符串 num1 和 num2 ，以及两个整数 max_sum 和 min_sum 。如果一个整数 x 满足以下条件，我们称它是一个好整数：\n\nnum1 <= x <= num2\nmin_sum <= digit_sum(x) <= max_sum.\n\n请你返回好整数的数目。答案可能很大，请返回答案对 109 + 7 取余后的结果。\n\n注意，digit_sum(x) 表示 x 各位数字之和。\n\n \n\n示例 1：\n\n输入：num1 = \"1\", num2 = \"12\", min_num = 1, max_num = 8\n输出：11\n解释：总共有 11 个整数的数位和在 1 到 8 之间，分别是 1,2,3,4,5,6,7,8,10,11 和 12 。所以我们返回 11 。\n\n\n示例 2：\n\n输入：num1 = \"1\", num2 = \"5\", min_num = 1, max_num = 5\n输出：5\n解释：数位和在 1 到 5 之间的 5 个整数分别为 1,2,3,4 和 5 。所以我们返回 5 。\n\n\n \n\n提示：\n\n1 <= num1 <= num2 <= 1022\n1 <= min_sum <= max_sum <= 400"}
{"date": "2023-12-20-18-59", "error": false, "url": "https://leetcode.com/problems/find-a-good-subset-of-the-matrix", "text_blocks": "给你一个下标从 0 开始大小为 m x n 的二进制矩阵 grid 。\n\n从原矩阵中选出若干行构成一个行的 非空 子集，如果子集中任何一列的和至多为子集大小的一半，那么我们称这个子集是 好子集。\n\n更正式的，如果选出来的行子集大小（即行的数量）为 k，那么每一列的和至多为 floor(k / 2) 。\n\n请你返回一个整数数组，它包含好子集的行下标，请你将子集中的元素 升序 返回。\n\n如果有多个好子集，你可以返回任意一个。如果没有好子集，请你返回一个空数组。\n\n一个矩阵 grid 的行 子集 ，是删除 grid 中某些（也可能不删除）行后，剩余行构成的元素集合。\n\n \n\n示例 1：\n\n输入：grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]\n输出：[0,1]\n解释：我们可以选择第 0 和第 1 行构成一个好子集。\n选出来的子集大小为 2 。\n- 第 0 列的和为 0 + 0 = 0 ，小于等于子集大小的一半。\n- 第 1 列的和为 1 + 0 = 1 ，小于等于子集大小的一半。\n- 第 2 列的和为 1 + 0 = 1 ，小于等于子集大小的一半。\n- 第 3 列的和为 0 + 1 = 1 ，小于等于子集大小的一半。\n\n\n示例 2：\n\n输入：grid = [[0]]\n输出：[0]\n解释：我们可以选择第 0 行构成一个好子集。\n选出来的子集大小为 1 。\n- 第 0 列的和为 0 ，小于等于子集大小的一半。\n\n\n示例 3：\n\n输入：grid = [[1,1,1],[1,1,1]]\n输出：[]\n解释：没有办法得到一个好子集。\n\n\n \n\n提示：\n\nm == grid.length\nn == grid[i].length\n1 <= m <= 104\n1 <= n <= 5\ngrid[i][j] 要么是 0 ，要么是 1 。"}
